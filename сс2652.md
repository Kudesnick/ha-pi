Прошивка СС2652 через Raspberry Pi

Проверено на примере прошивки модуля E72 2G4M05S1F на базе чипа CC2652RB. 

## Прошивка через JTAG

За основу взята [инструкция](https://gist.github.com/tobiasfrejo/d98e9f4cbbc6893662ab032b06388685). Однако, она несколько устарела и не работает в чистом виде. Для работы с последними сборками Raspbian будем собирать openocd из исходников. Обратимся к [инструкции с форума Raspberry Pi](https://forums.raspberrypi.com/viewtopic.php?t=242212) но и её придется модифицировать: добавить пакет [libgpiod](https://lloydrochester.com/post/hardware/libgpiod-intro-rpi/). Кроме того, возьмем исходники с [официального зеркала openocd на github](https://github.com/openocd-org/openocd).

Устанавливаем библиотеки, скачиваем openocd и конфигурируем:

~~~
# apt update && apt install telnet autoconf libtool pkg-config libusb-1.0-0 libusb-1.0-0-dev gpiod libgpiod-dev -y
$ git --depth 1 clone https://github.com/openocd-org/openocd.git
$ cd ./openocd/
$ ./bootstrap
$ ./configure --enable-bcm2835gpio --enable-sysfsgpio --prefix=/usr
~~~

Конечный вывод будет примерно таким:

~~~
OpenOCD configuration summary
--------------------------------------------------
MPSSE mode of FTDI based devices        yes (auto)
ST-Link Programmer                      yes (auto)
TI ICDI JTAG Programmer                 yes (auto)
Keil ULINK JTAG Programmer              yes (auto)
ANGIE Adapter                           yes (auto)
Altera USB-Blaster II Compatible        yes (auto)
Bitbang mode of FT232R based devices    yes (auto)
Versaloon-Link JTAG Programmer          yes (auto)
TI XDS110 Debug Probe                   yes (auto)
CMSIS-DAP v2 Compliant Debugger         yes (auto)
OSBDM (JTAG only) Programmer            yes (auto)
eStick/opendous JTAG Programmer         yes (auto)
Olimex ARM-JTAG-EW Programmer           yes (auto)
Raisonance RLink JTAG Programmer        yes (auto)
USBProg JTAG Programmer                 yes (auto)
Espressif JTAG Programmer               yes (auto)
CMSIS-DAP Compliant Debugger            no
Nu-Link Programmer                      no
Cypress KitProg Programmer              no
Altera USB-Blaster Compatible           no
ASIX Presto Adapter                     no
OpenJTAG Adapter                        no
SEGGER J-Link Programmer                no
Bus Pirate                              yes (auto)
Use Capstone disassembly framework      no
~~~

В оригинальной [инструкции с форума Raspberry Pi](https://forums.raspberrypi.com/viewtopic.php?t=242212) вывод содержал строку:

~~~
Linux GPIO bitbang through libgpiod     no
~~~

Если эта строка появилась, значит библиотека [libgpiod](https://lloydrochester.com/post/hardware/libgpiod-intro-rpi/) не установлена и программная эмуляция JTAG на пинах Raspberry работать не будет. Для исправления этого и понадобилась установка пакетов `gpiod` и `libgpiod-dev`.

Собираем и устанавливаем openocd:

~~~
$ make
# make install
cd ~
~~~

Конфигурируем openocd для работы с модулем E72 2GM05S1F на базе CC2652RB и скачиваем прошивку:

$ cp /usr/share/openocd/scripts/board/ti_cc26x2_launchpad.cfg openocd.cfg
$ sed -i "s|source \[find interface.*$|source [find interface/raspberrypi-native.cfg]|" openocd.cfg
$ sed -i "s/adapter speed.*$/adapter speed 200/" openocd.cfg
$ wget https://github.com/Koenkk/Z-Stack-firmware/raw/master/coordinator/Z-Stack_3.x.0/bin/CC2652RB_coordinator_20230507.zip
$ unzip -a CC2652RB_coordinator_20230507.zip
~~~

В оригинале `adapter speed` устанавливался в 1000 кГц, но т.к. я паял схему "на коленке", то для стабильной работы пришлось снизить частоту до 200 кГц. На этой частоте удалось добиться стабильной прошивки.

Подключаем наш модуль к Raspberry Pi Zero 2W по следующей схеме:

| Сигнал JTAG | пин CC2652RB | пин Raspberry | GPIO number         |
|-------------|--------------|---------------|---------------------|
| +3.3v       | VCC          | 17            | 3.3V                |
| GND         | GND          | 25            | GND                 |
| TMS         | TMSC         | 24            | GPIO08 CE0  (SPI 0) |
| TCK         | TCKC         | 23            | GPIO11 SCLK (SPI 0) |
| TDO         | DIO16        | 21            | GPIO09 MISO (SPI 0) |
| TDI         | DIO17        | 19            | GPIO10 MOSI (SPI 0) |

Запускаем `openocd` без параметров. Если модуль подключен корректно, вывод должен быть следующим:

~~~
Open On-Chip Debugger 0.12.0+dev-01556-ga35e254c5 (2024-03-30-05:06)
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Warn : TMS/SWDIO moved to GPIO 8 (pin 24). Check the wiring please!
cortex_m reset_config vectreset
Info : Listening on port 6666 for tcl connections
Info : Listening on port 4444 for telnet connections
Info : BCM2835 GPIO JTAG/SWD bitbang driver
Info : clock speed 500 kHz
Info : JTAG tap: cc26x2.jrc tap/device found: 0x3bb4102f (mfg: 0x017 (Texas Instruments), part: 0xbb41, ver: 0x3)
Info : JTAG tap: cc26x2.cpu enabled
Info : [cc26x2.cpu] Cortex-M4 r0p1 processor detected
Info : [cc26x2.cpu] target has 6 breakpoints, 4 watchpoints
Info : [cc26x2.cpu] Examination succeed
Info : starting gdb server for cc26x2.cpu on 3333
Info : Listening on port 3333 for gdb connections
~~~

Подключаемся к telnet. Это нужно делать не закрываю процесс openocd. Т.к. я подключился к Raspberry по ssh, я просто открыл еще одну вкладку терминала. Сначала я пытался работать в одной вкладке через `mux`, запущенный на Raspberry, но `openocd` выдавал ошибку, с которой я не стал разбираться на данном этапе:

~~~
Open On-Chip Debugger 0.12.0+dev-01556-ga35e254c5 (2024-03-27-02:01)
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
openocd.cfg:6: Error: Can't find interface/raspberrypi-native.cfg
in procedure 'script'
at file "embedded:startup.tcl", line 28
at file "openocd.cfg", line 6
Info : Listening on port 6666 for tcl connections
Info : Listening on port 4444 for telnet connections
Error: Debug Adapter has to be specified, see "adapter driver" command
openocd.cfg:6: Error:
in procedure 'script'
at file "embedded:startup.tcl", line 28
at file "openocd.cfg", line 6
~~~

Итак, запускаем telnet в отдельной вкладке терминала и прошиваем модуль:

~~~
$ telnet 4444
> init
> reset
> halt
> flash write_image erase CC2652RB_coordinator_20230507.hex
> flash verify_image CC2652RB_coordinator_20230507.hex
~~~

Финальный вывод должен быть таким:

~~~
verified 183584 bytes from file CC2652RB_coordinator_20230507.hex in 0.910136s (196.983 KiB/s)
~~~

## Обновление прошивки

Добавляем к схеме подключения UART и схему управления сбросом:

| Сигнал CC2652RB | пин CC2652RB | пин Raspberry | GPIO number    |
|-----------------|--------------|---------------|----------------|
| RESET           | RESET        | 7             | GPIO04         |
| FLASH           | FLASH        | 13            | GPIO27         |
| RX              | DIO12        | 8             | GPIO14 UART TX |
| TX              | DIO13        | 10            | GPIO15 UART RX |
| GREEN LED       | DIO6         | NC            | NA             |
| RED LED         | DIO7         | NC            | NA             |

За основу взята [официальная инструкция](https://www.zigbee2mqtt.io/guide/adapters/#recommended), в ней дана ссылка на прошивку с помощью утилиты [cc2538-bsl](https://github.com/codm/cc2652-raspberry-pi-module#firmware).

> **ⓘ**
>
> Перед тем, как приступить к подключению, необходимо освободить от консольного вывода аппаратный UART.
> См. [Настройка serial port](./CC2530.md#настройка-serial-port)

Сбрасываем чип и переводим в режим программирования:

~~~
$ gpioset gpiochip0  4=0
$ gpioset gpiochip0 27=0
$ sleep 1
$ gpioset gpiochip0  4=1
$ sleep 1
$ gpioset gpiochip0 27=1
~~~
